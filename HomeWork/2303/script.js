// Попробуйте минимальным количеством слов объяснить как работает жадный алгоритм?
// Всегда ли жадный алгоритм работает, почему?

// ***
// Жадный алгоритм выбирает локально оптимальное решение на каждом шаге, не учитывая будущих последствий. Он продолжает так делать до тех пор, пока не будет найдено глобально оптимальное решение.
// Жадный алгоритм не всегда работает, потому что локально оптимальные решения могут не привести к глобально оптимальному решению.В таких случаях, для достижения глобально оптимального решения, требуется использовать другие алгоритмы, которые могут рассматривать больше вариантов выбора на каждом шаге.
//***

// Задача выбора активностей
// Стояла задача - отсортировать все заявки по времени окончания активности в порядке возрастания. Для этого выбиралась  первая заявка из отсортированного списка и помещалась в список выбранных заявок. Потом шел обход всех заявок и выбирались только те,  начало которых происходило после окончания предыдущей выбранной заявки.
// Выбранные заявки были добавлены в список выбранных заявок и продолжался обход  оставшихся заявок до тех пор, пока все не были проверены.
// Решением было вернуть список всех выбранных заявок.

// function find(table) {
//   table.sort((a, b) => a.end - b.end);

//   const selectedActivities = [];
//   let lastActivityEnd = -Infinity;

//   for (const activity of table) {
//     if (activity.start >= lastActivityEnd) {
//       selectedActivities.push(activity);
//       lastActivityEnd = activity.end;
//     }
//   }
//   return selectedActivities;
// }

// const activities = [
//   { start: 14, end: 15 },
//   { start: 15, end: 16 },
//   { start: 10, end: 11 },
//   { start: 14, end: 17 },
//   { start: 11, end: 13 },
//   { start: 10, end: 15 },
//   { start: 12, end: 13 },
//   { start: 16, end: 17 },
// ];

// const selectedActivities = find(activities);
// console.log(selectedActivities);

//***
// Теперь необходимо адаптировать решение этой задачи для ситуации со стоимостью работы.
//  Т е заявка 1 start: 10 end: 12, ценник: 2 у.е.
//  Т е заявка 2 start: 11 end: 15, ценник: 1 у.е.
//  Приоритет отдаем той, что дороже, т е заявке 2

// ***
// Для адаптации решения задачи выбора активностей для ситуации со стоимостью работы необходимо изменить способ сортировки списка заявок. Вместо сортировки по времени окончания активности, нужно отсортировать заявки по их стоимости в порядке убывания. Затем можно использовать тот же алгоритм, что и в исходном решении, но при выборе следующей заявки проверять не только время ее начала, но и ее стоимость. Таким образом, из доступных заявок выбирается та, у которой самая высокая стоимость и время начала больше или равно времени окончания предыдущей выбранной заявки.

// Решени. Заявки сортируются по их стоимости в порядке убывания, а при выборе следующей заявки проверяется ее время начала и стоимость.

function find(table) {
  table.sort((a, b) => b.cost - a.cost);

  const selectedActivities = [];
  let lastActivityEnd = -Infinity;

  for (const activity of table) {
    if (activity.start >= lastActivityEnd && activity.cost > 0) {
      selectedActivities.push(activity);
      lastActivityEnd = activity.end;
    }
  }
  return selectedActivities;
}

const activities = [
  { start: 14, end: 15, cost: 3 },
  { start: 15, end: 16, cost: 2 },
  { start: 10, end: 11, cost: 5 },
  { start: 14, end: 17, cost: 4 },
  { start: 11, end: 13, cost: 2 },
  { start: 10, end: 15, cost: 1 },
  { start: 12, end: 13, cost: 1 },
  { start: 16, end: 17, cost: 3 },
];

const selectedActivities = find(activities);
console.log(selectedActivities);

// ***
